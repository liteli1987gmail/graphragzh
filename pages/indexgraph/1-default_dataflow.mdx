

# 索引数据流

## 知识图谱相关知识模型

知识模型是符合我们数据模型定义的数据输出规范。你可以在 GraphRAG 存储库的 python/graphrag/graphrag/model 文件夹中找到这些定义。提供以下实体类型。这里的字段代表默认情况下文本嵌入的字段。

- `Document` - 进入系统的输入文档。这些可以代表 CSV 中的单个行或单个.txt 文件。
- `TextUnit` - 要分析的文本块。这些块的大小，重叠和是否符合任何数据边界可以在下面进行配置。常见用例是将 `CHUNK_BY_COLUMNS` 设置为 `id`，以便文档和 TextUnit 之间存在一对多关系，而不是多对多关系。
- `Entity` - 从 TextUnit 中提取的实体。这些代表你提供的人物，地点，事件或其他实体模型。
- `Relationship` - 两个实体之间的关系。这些由协变量生成。
- `Covariate` - 提取的声明信息，包含关于可能随时间变化的实体的陈述。
- `Community Report` - 生成实体后，我们对其进行层次化社区检测，并为层次结构中的每个社区生成报告。
- `Node` - 该表包含嵌入和聚类的实体和文档的渲染知识图谱视图的布局信息。

## 默认配置工作流程

让我们看看默认配置工作流程如何将文本文档转换为_知识图谱相关知识模型_。该页面提供了该过程中主要步骤的概述。要完全配置此工作流程，请查看 [配置](/indexgraph/config/overview/) 文档。

![](/img/1-default_dataflow.png)

## 第一阶段：组合 TextUnits

默认配置工作流程的第一阶段是将输入文档转换为_TextUnits_。_TextUnit_是用于我们的知识图谱提取技术的一块文本。它们还被提取的知识项用作源引用，以通过概念将面包屑和证明相关联到其原始源文本。

块大小（以记号计数）是可由用户配置的。默认情况下，这设置为 300 个令牌，尽管我们使用单个 "glean" 步骤使用 1200 个令牌块取得了积极的经验。（“glean”步骤是一种后续提取）。较大的块会导致输出的保真度降低，参考文本的含义更少；然而，使用较大的块可以大大加快处理时间。

分组配置也可由用户配置。默认情况下，我们将我们的块与文档边界对齐，这意味着文档与 TextUnits 之间存在严格的一对多关系。在罕见的情况下，可以将其变成多对多关系。当文档非常短且我们需要几个文档来组成一个有意义的分析单元时，这是很有用的（例如推文或聊天记录）

这些文本单元都是被嵌入文本，并传递到下一个阶段的流水线。

![](/img/text-unitsaretext-embedded.png)

## 第二阶段：知识图谱提取

现在我们进入的这个阶段，我们会分析每个文本单元并提取我们的知识图谱基元：_实体_，_关系_和_主张_。
实体和关系在我们的 _entity_extract_ 动词中一次性提取，而主张则在我们的 _claim_extract_ 动词中提取。然后将结果合并并传递到管道的后续阶段。

![](/img/Phase2.png)


### 实体和关系提取

在知识图谱提取的第一步中，我们处理每个文本单元，以从原始文本中使用 LLM 提取实体和关系。此步骤的输出是一个包含 **实体** 列表（具有_name_，_type_和_description_）和 **关系** 列表（具有_source_，_target_和_description_）的 TextUnit 的子图。

这些子图会合并在一起 - 具有相同_name_和_type_的实体将通过创建其描述数组进行合并。同样，具有相同_source_和_target_的任何关系将通过创建其描述数组进行合并。

### 实体和关系概述

现在，我们有了一个包含具有描述列表的实体和关系的知识图谱，我们可以将这些列表总结为每个实体和关系的单个描述。通过询问 LLM 获取能够捕捉到每个描述中所有不同信息的简要概述来实现这一点。这样，我们所有的实体和关系都可以具有一个简洁的描述。

### 实体解析（默认情况下未启用）

知识图谱提取的最后一步是解析任何表示相同现实世界实体但具有不同名称的实体。由于这是通过 LLM 完成的，我们不想丢失信息，因此我们希望采用保守的、无破坏性的方法来解决这个问题。

然而，我们当前的实体解析实现是破坏性的。它将提供一系列实体给 LLM，并要求其确定哪些实体应合并。然后将这些实体合并为一个实体，并更新它们的关系。

我们目前正在探索其他实体解析技术。在不久的将来，实体解析将通过在实体变量之间创建边来执行，这表明实体已通过索引引擎被解析。这将允许最终用户撤消索引端解析，并使用类似的过程添加他们自己的无破坏解析。

### 主张提取和发射

最后作为一个独立的工作流，我们从源 TextUnits 中提取主张。这些主张代表了具有评估状态和时间边界的正面事实陈述。这些都作为名为 **Covariates** 的主要工件发射出来。

## 阶段 3：知识图谱增强

现在，我们有了一个可用的实体和关系知识图谱，我们希望了解它们的社区结构并增强知识图谱以获取更多信息。这分为两个步骤：_社区检测_和_知识图谱嵌入_。这些步骤可以明确（社区）和隐含（嵌入）地理解知识图谱的拓扑结构。

![](/img/Phase3.png)

### 社区检测

在这一步中，我们使用层次 Leiden 算法生成实体社区的层次结构。该方法将对我们的知识图谱应用递归的社区聚类，直到达到社区大小阈值。这将使我们能够了解我们的网络的社区结构，并提供在不同粒度级别上导航和总结知识图谱的方法。

### 知识图谱嵌入

在这一步中，我们使用 Node2Vec 算法生成知识图谱的向量表示。这将使我们能够理解我们的知识图谱的隐含结构，并提供一个额外的向量空间，用于在查询阶段搜索相关概念。

### 知识图谱表发射

一旦我们完成了知识图谱增强步骤，我们会对 **实体** 和 **关系** 表进行发射，之后再进行文本域的文本嵌入。

## 阶段 4：社区总结

![](/img/Phase4.png)
在这一点上，我们有了一个可用的实体和关系图，以及实体的层次结构和 node2vec 嵌入。

现在我们希望在社区数据的基础上生成报告。这将使我们能够更深入地了解知识图谱在各个粒度级别上的高层次情况。例如，如果社区 A 是最高层级的社区，我们将获得有关整个知识图谱的报告。如果社区是较低级别的，则我们将获得有关局部集群的报告。

### 生成社区报告

在这一步中，我们使用 LLM 生成每个社区的摘要。这将使我们能够了解每个社区中包含的不同信息，并从高层次或低层次的角度提供对知识图谱的范围性理解。这些报告包含管理概述，并引用社区子结构中的关键实体、关系和主张。

### 总结社区报告

在这一步中，每个_社区报告_会经过 LLM 进行摘要，供简要使用。

### 社区嵌入

在这一步中，我们通过生成社区报告、社区报告摘要和社区报告标题的文本嵌入，生成我们社区的向量表示。

### 社区表发射

此时，我们进行一些簿记工作，然后发射 **社区** 和 **社区报告** 表格。

## 阶段 5：文档处理

本流程的工作阶段是为知识模型创建“文档”表。

![](/img/Phase5.png)

### 使用列扩充（仅限 CSV）

如果工作流在 CSV 数据上运行，则可以配置工作流以向文档输出添加其他字段。这些字段应该存在于传入的 CSV 表中。有关配置的详细信息可以在 [配置文档](/indexgraph/config/overview/) 中找到。

### 链接到文本单元

在这一步中，我们将每个文档链接到在第一阶段创建的文本单元。这样我们就能知道哪些文档与哪些文本单元相关。

### 文档嵌入

在这一步中，我们使用文档片段的平均嵌入生成文档的向量表示。我们重新分块文档，没有重叠的块，然后为每个块生成一个嵌入。我们通过标记计数加权这些块的平均值，并将其用作文档嵌入。这将使我们能够理解文档之间的隐含关系，并帮助我们生成文档的网络表示。

### 文档表发射

此时，我们可以将 **文档** 表发射到知识模型中。

## 第 6 阶段：网络可视化



在工作流的这个阶段，我们执行一些步骤，以支持在现有知识图谱中可视化高维向量空间的网络。此时有两个逻辑图正在工作：实体关系图和文档图。

![](/img/Phase6.png)

对于每个逻辑图，我们执行 UMAP 降维来生成知识图谱的 2D 表示。这将使我们能够在 2D 空间中可视化知识图谱并理解知识图谱中节点之间的关系。然后，UMAP 嵌入作为“节点”表格发出。此表格的行包括一个判别器，指示节点是文档还是实体，以及 UMAP 坐标。
